<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AFK Mode ‚Äî Accumulate and Win üöÄ</title>
  <style>
    :root {
      --bg: #0b1115; --panel: #0e141a; --panel2: #111a22; --text: #dfe7ef;
      --muted: #9db0c0; --accent: #2bd081; --accent2: #11a372; --danger: #ff4d4d;
      --border: #15202b; --gold: #ffc700;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
    a { color: var(--accent); text-decoration: none; }
    .wrap { max-width: 800px; margin: 0 auto; padding: 28px 16px 60px; }
    .title { font-size: 28px; font-weight: 800; letter-spacing: .2px; display: flex; align-items: center; gap: 10px; }
    .sub { color: var(--muted); margin-top: 6px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 18px; margin-top: 24px; }
    .card { background: linear-gradient(180deg, var(--panel), var(--panel2)); border: 1px solid var(--border); border-radius: 18px; padding: 18px; }
    .row { display: flex; gap: 12px; align-items: center; }
    .muted { color: var(--muted); }
    .section-title { font-weight: 700; margin-bottom: 12px; font-size: 18px; }
    .btn {
      border: 1px solid var(--border); background: #101a21; color: var(--text); border-radius: 12px; padding: 11px 14px;
      cursor: pointer; transition: all .15s ease; font-weight: 700; font-size: 14px; width: 100%;
    }
    .btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: var(--accent); color: #041417; border-color: transparent; }
    .btn-danger { background: var(--danger); color: #1f0a0a; border-color: transparent; }
    .btn-play { padding: 16px; font-size: 20px; margin-top: 12px; }
    .kpi { display: flex; flex-direction: column; gap: 4px; padding: 14px; background: #0e171e; border: 1px dashed var(--border); border-radius: 14px; text-align: center; }
    .kpi .v { font-size: 32px; font-weight: 800; color: var(--gold); }
    .kpi-group { display: flex; justify-content: center; gap: 14px; margin-bottom: 16px; }
    .kpi-group .kpi .v { font-size: 22px; color: var(--text); }
    .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: #091218; border: 1px solid var(--border); border-radius: 14px; padding: 12px; height: 250px; overflow: auto; white-space: pre-wrap;
      font-size: 13px; line-height: 1.6;
    }
    #ranking-list { padding-left: 20px; margin: 0; list-style-type: none; }
    #ranking-list li { margin-bottom: 8px; font-size: 15px; display: flex; align-items: center; gap: 10px; }
    #ranking-list li span { font-weight: 600; color: var(--muted); width: 25px; text-align: right; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">AFK Mode ‚Äî Accumulate and Win üöÄ</div>
    <div class="sub">Compra $AFK para acumular tiempo de juego. ¬°Mientras m√°s compres, m√°s durar√° la partida y mejores ser√°n los premios!</div>

    <div class="grid">
      <div class="card" id="admin-panel" style="display: none;">
        <div class="section-title">‚öôÔ∏è Panel de Administrador</div>
        <button id="resetWeeklyBtn" class="btn btn-danger">Resetear Ranking Semanal</button>
      </div>

      <div class="card">
        <div class="section-title">Panel de Control</div>
        <div class="row">
          <button id="connect" class="btn">1. Conectar Wallet</button>
          <button id="buyAfk" class="btn btn-primary">2. Comprar $AFK</button>
        </div>
        <div id="pubkey" class="muted" style="text-align:center; margin-top:12px; font-size:13px;">Wallet no conectada</div>
      </div>

      <div class="card" id="game-panel">
        <div id="play-mode">
          <div class="section-title">Zona de Juego</div>
          <div class="kpi" style="margin-bottom: 16px;">
            <div class="muted">Tiempo de Juego Disponible</div>
            <div id="unclaimedTime" class="v">0:00</div>
          </div>
          <button id="playButton" class="btn btn-primary btn-play" disabled>JUGAR</button>
        </div>

        <div id="afk-display" style="display: none;">
          <div class="section-title">Sesi√≥n de Juego Activa</div>
          <div class="kpi-group">
            <div class="kpi"><div class="muted">Tiempo Restante</div><div id="afkTime" class="v">0:00</div></div>
            <div class="kpi"><div class="muted">Puntos de la Sesi√≥n</div><div id="pointsSession" class="v">0</div></div>
          </div>
        </div>
      </div>
      
      <div class="card">
         <div class="section-title">Puntaje Total</div>
         <div class="kpi"><div id="pointsTotal" class="v">0</div></div>
      </div>

      <div class="card">
        <div class="section-title">üèÜ Ranking de Jugadores (Top 10)</div>
        <ol id="ranking-list">
          <li>Cargando ranking...</li>
        </ol>
      </div>

      <div class="card">
        <div class="section-title">Registro de Actividad</div>
        <div id="log" class="log"></div>
      </div>
    </div>
  </div>

<script>
    // ========= CONFIGURACI√ìN =========
    const BACKEND_URL = "https://api.afkcoin.xyz";
    const IGNITER_URL = 'https://igniter.solaxy.io/token/?mint=1THEbQ2K1ELPQcsgfWhbSyApMeiXhofRexvmTVFvDfX';
    
    // IMPORTANTE: Pon aqu√≠ la direcci√≥n de tu billetera de administrador
    const ADMIN_PUBKEY = "F3zY8TZ9jiCTneBkPQr1DMbyT9vgwdBUXCoZB9h4GP5G";

    const WORKER_BASE = "https://afk-balance-worker.afkcoin.workers.dev";
    const AFK_DETECT_URL = `${WORKER_BASE}/afkRecentBuy`;
    const DETECT_INTERVAL_MS = 8000;
    const DETECT_WINDOW_MIN = 30;

    const RANKING_URL = `${BACKEND_URL}/ranking`;
    const RANKING_REFRESH_MS = 30000;

    // --- Definici√≥n de Tiers y Recompensas ---
    const TIERS = {
        legendary: { minAmount: 2500, seconds: 300, name: "Legendario" },
        rare:      { minAmount: 500,  seconds: 180, name: "Raro" },
        basic:     { minAmount: 1,    seconds: 60,  name: "B√°sico" }
    };
    const tierPrecedence = ['basic', 'rare', 'legendary'];
    const REWARDS_CONFIG = {
        basic: { rewards: { jackpot: 1000, high: 200, mid: 50, low: 10 }, probs: { jackpot: 0.01, high: 0.05, mid: 0.2 } },
        rare: { rewards: { jackpot: 10000, high: 1000, mid: 250, low: 50 }, probs: { jackpot: 0.02, high: 0.08, mid: 0.25 } },
        legendary: { rewards: { jackpot: 250000, high: 5000, mid: 1000, low: 200 }, probs: { jackpot: 0.005, high: 0.1, mid: 0.3 } },
    };

    // --- Estado de la Aplicaci√≥n ---
    const state = {
        pubkey: null,
        running: false,
        purchaseDetector: null,
        unclaimedSeconds: 0,
        highestTier: null,
        totalPoints: 0,
        afkStart: null,
        sessionDuration: 0,
        sessionTier: null,
        sessionPoints: 0
    };

    const $ = sel => document.querySelector(sel);
    const log = (msg) => { const box = $('#log'); const t = new Date().toLocaleTimeString(); box.innerHTML = `[${t}] ${msg}<br>` + box.innerHTML; }
    const fmt = (s) => { const m = Math.floor(s / 60), ss = String(Math.floor(s % 60)).padStart(2, '0'); return `${m}:${ss}` };

    function render() {
        $('#unclaimedTime').textContent = fmt(state.unclaimedSeconds);
        $('#playButton').disabled = !state.pubkey || state.running || state.unclaimedSeconds <= 0;
        $('#pointsTotal').textContent = state.totalPoints.toFixed(0);

        if (state.running) {
            const elapsed = (Date.now() - state.afkStart) / 1000;
            const remaining = Math.max(0, state.sessionDuration - elapsed);
            $('#afkTime').textContent = fmt(remaining);
            $('#pointsSession').textContent = state.sessionPoints.toFixed(0);
        }
    }

    // --- L√ìGICA DE DETECCI√ìN DE COMPRA ---
    function alreadyRewarded(sig) { try { return localStorage.getItem(`afk_bonus_${sig}`) === "1"; } catch { return false; } }
    function markRewarded(sig) { try { localStorage.setItem(`afk_bonus_${sig}`, "1"); } catch { } }

    async function checkRecentPurchase(pubkey) {
        try {
            const r = await fetch(`${AFK_DETECT_URL}?pubkey=${encodeURIComponent(pubkey)}&minutes=${DETECT_WINDOW_MIN}`);
            const j = await r.json();
            if (j && j.ok && j.purchased) return j;
        } catch (e) { console.error("Error checking purchase:", e); }
        return null;
    }

    async function purchaseDetectionLoop() {
        if (!state.pubkey || state.running) return;
        log('üîé Buscando compras de $AFK...');
        const purchase = await checkRecentPurchase(state.pubkey);

        if (purchase && !alreadyRewarded(purchase.signature)) {
            markRewarded(purchase.signature);
            
            let tierId = null;
            if (purchase.amount >= TIERS.legendary.minAmount) tierId = 'legendary';
            else if (purchase.amount >= TIERS.rare.minAmount) tierId = 'rare';
            else if (purchase.amount >= TIERS.basic.minAmount) tierId = 'basic';

            if(tierId) {
                const tierInfo = TIERS[tierId];
                state.unclaimedSeconds += tierInfo.seconds;
                log(`‚úÖ ¬°Compra detectada! Has ganado ${tierInfo.seconds}s de juego (Nivel ${tierInfo.name}).`);
                
                if (!state.highestTier || tierPrecedence.indexOf(tierId) > tierPrecedence.indexOf(state.highestTier)) {
                    state.highestTier = tierId;
                    log(`‚ú® Tu pr√≥ximo juego tendr√° recompensas de nivel ${tierInfo.name}.`);
                }
                render();
            }
        }
    }

    function startPurchaseDetector() {
        if (state.purchaseDetector) clearInterval(state.purchaseDetector);
        state.purchaseDetector = setInterval(purchaseDetectionLoop, DETECT_INTERVAL_MS);
        log('Detector de compras activado.');
    }

    function stopPurchaseDetector() {
        if (state.purchaseDetector) {
            clearInterval(state.purchaseDetector);
            state.purchaseDetector = null;
            log('Detector de compras en pausa.');
        }
    }
    
    // --- L√ìGICA DEL JUEGO ---
    function toggleViews(showAFK) {
        $('#play-mode').style.display = showAFK ? 'none' : 'block';
        $('#afk-display').style.display = showAFK ? 'block' : 'none';
    }

    function calculateRewardDrop(tier) {
        const config = REWARDS_CONFIG[tier];
        const roll = Math.random();
        if (roll < config.probs.jackpot) return { points: config.rewards.jackpot, msg: `üöÄ ¬°¬°JACKPOT!! +${config.rewards.jackpot}` };
        if (roll < config.probs.jackpot + config.probs.high) return { points: config.rewards.high, msg: `üíé ¬°DROP √âPICO! +${config.rewards.high}` };
        if (roll < config.probs.jackpot + config.probs.high + config.probs.mid) return { points: config.rewards.mid, msg: `üî• ¬°Buen premio! +${config.rewards.mid}` };
        return Math.random() < 0.4 ? { points: 0 } : { points: config.rewards.low, msg: `+${config.rewards.low}` };
    }

    let gameLoop;
    function startAFK() {
        if (state.running || state.unclaimedSeconds <= 0) return;

        state.sessionDuration = state.unclaimedSeconds;
        state.sessionTier = state.highestTier || 'basic';
        state.unclaimedSeconds = 0;
        state.highestTier = null;
        
        state.running = true;
        state.afkStart = Date.now();
        state.sessionPoints = 0;
        
        toggleViews(true);
        log(`üöÄ ¬°Juego iniciado! Duraci√≥n: ${fmt(state.sessionDuration)}, Nivel: ${TIERS[state.sessionTier].name}`);
        stopPurchaseDetector();

        gameLoop = setInterval(() => {
            const elapsedSeconds = (Date.now() - state.afkStart) / 1000;
            const lastRewardCheck = Math.floor((elapsedSeconds - 1) / 3);
            const currentRewardCheck = Math.floor(elapsedSeconds / 3);

            if (currentRewardCheck > lastRewardCheck) {
                const reward = calculateRewardDrop(state.sessionTier);
                if (reward.points > 0) {
                    state.sessionPoints += reward.points;
                    log(reward.msg);
                }
            }

            if (elapsedSeconds >= state.sessionDuration) {
                stopAFK();
            } else {
                render();
            }
        }, 1000);
    }

    async function stopAFK() {
        if (!state.running) return;
        clearInterval(gameLoop);
        state.running = false;

        state.totalPoints += state.sessionPoints;
        log(`üèÅ Sesi√≥n terminada. Ganaste ${state.sessionPoints} puntos. Total: ${state.totalPoints}`);
        
        toggleViews(false);
        if (state.pubkey) {
            startPurchaseDetector();
            await savePointsToServer();
            await fetchRanking();
        }
        render();
    }

    // --- L√ìGICA DEL RANKING ---
    function renderRanking(rankingData) {
        const list = $('#ranking-list');
        if (!rankingData || rankingData.length === 0) {
            list.innerHTML = '<li>A√∫n no hay datos en el ranking.</li>';
            return;
        }

        const topEmojis = ['ü•á', 'ü•à', 'ü•â'];
        
        // Filtramos la wallet del admin antes de mostrar los datos.
        const filteredRanking = rankingData.filter(player => player.pubkey !== ADMIN_PUBKEY);

        list.innerHTML = filteredRanking.slice(0, 10).map((player, index) => {
            const key = player.pubkey;
            const truncatedKey = `${key.slice(0, 4)}‚Ä¶${key.slice(-4)}`;
            const emoji = topEmojis[index] || `<span>#${index + 1}</span>`;
            return `<li>${emoji} ${truncatedKey} - <strong>${player.points.toFixed(0)} Puntos</strong></li>`;
        }).join('');
    }

    async function fetchRanking() {
        try {
            const res = await fetch(RANKING_URL);
            if (!res.ok) throw new Error(`El servidor respondi√≥ con status ${res.status}`);
            const result = await res.json();
            renderRanking(result);
        } catch (err) {
            log('‚ùå No se pudo cargar el ranking.');
            console.error("Error fetching ranking:", err);
            $('#ranking-list').innerHTML = '<li>Error al cargar el ranking.</li>';
        }
    }

    // --- CONEXI√ìN Y SERVIDOR ---
    async function connectWallet() {
        const provider = window.solana;
        if (!provider || !provider.isPhantom) {
            log('‚ùå Phantom Wallet no detectada. Por favor, inst√°lala.');
            return;
        }
        try {
            const resp = await provider.connect();
            const key = resp.publicKey.toString();
            state.pubkey = key;
            $('#pubkey').textContent = `Wallet: ${key.slice(0, 4)}‚Ä¶${key.slice(-4)}`;
            log('‚úÖ Wallet conectada.');
            
            if (key === ADMIN_PUBKEY) {
                log('üëã ¬°Hola, Admin! Panel de control activado.');
                $('#admin-panel').style.display = 'block';
            } else {
                $('#admin-panel').style.display = 'none';
            }
            
            await loadPointsFromServer(key);
            startPurchaseDetector();
            purchaseDetectionLoop();
        } catch (err) {
            log('‚ùå Conexi√≥n rechazada por el usuario.');
        }
    }
    
    async function loadPointsFromServer(pubkey) {
        try {
            const res = await fetch(`${BACKEND_URL}/points/${pubkey}`);
            if (res.ok) {
                const data = await res.json();
                state.totalPoints = data.points || 0;
                log(`Puntaje total cargado: ${state.totalPoints}`);
            } else {
                 log('Nueva wallet. ¬°Bienvenido!');
                 state.totalPoints = 0;
            }
        } catch (err) {
            log('‚ùå No se pudo conectar al servidor de puntajes.');
            state.totalPoints = 0;
        } finally {
            render();
        }
    }

    async function savePointsToServer() {
        if (!state.pubkey) return;
        try {
            await fetch(`${BACKEND_URL}/savePoints`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ pubkey: state.pubkey, points: state.totalPoints })
            });
            log('Puntaje guardado en el servidor.');
        } catch (err) {
            log('‚ùå No se pudo sincronizar el puntaje.');
        }
    }

    // --- FUNCIONES DE ADMINISTRADOR ---
    async function resetWeeklyRanking() {
      if (!confirm('¬øEst√°s seguro de que quieres resetear los puntos semanales de TODOS los jugadores a cero?')) {
        return;
      }
      log('‚öôÔ∏è Reseteando ranking semanal...');
      try {
        const res = await fetch(`${BACKEND_URL}/resetWeekly`, { method: 'POST' });
        const data = await res.json();
        if (res.ok && data.ok) {
          log('‚úÖ Ranking semanal reseteado con √©xito.');
          await fetchRanking();
        } else {
          throw new Error(data.error || 'Respuesta no OK del servidor');
        }
      } catch (err) {
        log('‚ùå Error al resetear el ranking.');
        console.error('Reset error:', err);
      }
    }

    // --- INICIALIZACI√ìN ---
    $('#connect').addEventListener('click', connectWallet);
    $('#buyAfk').addEventListener('click', () => {
        log('Abriendo exchange para comprar $AFK...');
        window.open(IGNITER_URL, '_blank');
    });
    $('#playButton').addEventListener('click', startAFK);
    $('#resetWeeklyBtn').addEventListener('click', resetWeeklyRanking);

    log('Bienvenido. Conecta tu wallet para empezar.');
    render();
    
    fetchRanking();
    setInterval(fetchRanking, RANKING_REFRESH_MS);
</script>
</body>
</html>